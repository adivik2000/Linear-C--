{
    "toc":[

{"title":"Arrays", "section":"c"},{"title":"Copying Strings", "section":"c"},{"title":"The malloc() function", "section":"c"},{"title":"Reading From a File", "section":"c"}    ],

    "results":[


{"title" : "Arrays", "section":"c", "description":"Arrays in C are just pointers to the first element in the array.\r<br />\r<br />You can have two-dimensional, three-dimensional arrays, four-dimensional etc arrays in C.\r<br />\r<br /><code class=\"code prettyprint\"># an array of chars (a string)\r<br />char name[40];\r<br />\r<br /># an array of 100 ints\r<br />int hundred[100];\r<br />\r<br /># initializing the array\r<br />char name[40] = {'E','n','i','d'};\r<br />\r<br /># if you don't specify an array length, it is automatically as long as the # of elements it's initialized with:\r<br />char name[ ] = {'E','n','i','d'};\r<br />\r<br /># two-dimensional array\r<br /># int myarray[rows][columns]\r<br />int myarray[100][100];\r<br />\r<br />#initializing:\r<br />int myarray[][] = \r<br />{\r<br />{00,01,02,03,04},\r<br />{10,11,12,13,14},\r<br />{20,21,22,23,24}\r<br />}\r<br /></code>\r<br />\r<br /><strong>Initialize Array To Zero</strong>\r<br />If you initialize an array, C will automatically set the rest of the elements in the array to zero. So if you want to initialize all the elements in an array to zero, you just need to set the first one to zero:\r<br />\r<br /><code class=\"code prettyprint\">int myarray[100] = {0}; // all 100 elements are now zero.\r<br /></code>\r<br />\r<br /><strong>Getting The Size Of An Array</strong>\r<br />This is a convoluted operation in C. Here's how you do it:\r<br />\r<br /><code class=\"code prettyprint\">int foo[10]; // declare the array\r<br />int foo_size = sizeof(foo)/sizeof(*foo); // get the size\r<br /></code>\r<br />\r<br /><strong>Pointers To Arrays</strong>\r<br />Since all an array really is is a pointer to the first element in the array, you don't use the '&' operator to get the address of the array...you just use the array name. Example:\r<br />\r<br /><code class=\"code prettyprint\">  int test[100];\r<br />  test[1] = 444;\r<br />  \r<br />  int * hello = test;\r<br />  hello++;\r<br />  printf(\"%d\",*hello);\r<br /></code>\r<br />\r<br />This will print '444'.\r<br />\r<br />You <strong>can't</strong> assign pointers to arrays though. That is, suppose we have a function copy_uppercase that returns a pointer to an array. Then:\r<br />\r<br /><code class=\"code prettyprint\">  // this is fine, a pointer assigned to a pointer\r<br />  char *array2;\r<br />  array2 = copy_uppercase(array);\r<br />  \r<br />  // this is not fine, a pointer assigned to an array\r<br />  char array2[];\r<br />  array2 = copy_uppercase(array);\r<br /></code>", "code":"" },
{"title" : "Copying Strings", "section":"c", "description":"Include string.h:\r<br /><code class=\"code prettyprint\">#include &lt;string.h&gt;\r<br /></code>\r<br />\r<br />Use strcpy(). Notice how we're using an array with a specific size for 'copyto'. Declaring an array allocates storage space for data; declaring a pointer only allocates storage space for one address.", "code":"char * copyfrom = \"hello\";\r<br />char copyto[100];\r<br />strcpy(copyto,copyfrom);" },
{"title" : "The malloc() function", "section":"c", "description":"We have to include stdlib.h:\r<br /><code class=\"code prettyprint\">#include &lt;stdlib.h&gt;\r<br /></code>\r<br />\r<br />This allows you to allocate memory dynamically as the program runs.\r<br />malloc() takes one argument: the number of bytes of memory you want. It then finds a suitable block of free memory and returns the address of the first byte of that block.\r<br />For example, here we are creating an array of doubles:\r<br />\r<br /><code class=\"code prettyprint\">double * ptd;\r<br />ptd = (double *) malloc (30 * sizeof(double));\r<br />\r<br /># since it's an array, you can now use it like this:\r<br />ptd[0] = 1234;\r<br />ptd[1] = 5678;\r<br /></code>\r<br />\r<br />malloc() will return the null pointer if it couldn't find the required memory.", "code":"" },
{"title" : "Reading From a File", "section":"c", "description":"You can use <strong>fread()</strong>, <strong>fscanf()</strong> or <strong>fgets()</strong> to read from a file.\r<br />\r<br /><strong>fread()</strong>\r<br />Use this after you have a file descriptor. Use fopen() to get the file descriptor (<strong>not</strong> open).\r<br />\r<br />fread takes four arguments:\r<br />The first is a char * - this could be an actual char pointer or a char array.\r<br />The second argument is the max amount to read.\r<br />The third argument in the number of elements to read. This only has an effect if you passed a char array as opposed to a char pointer; if you passed a char pointer, it doesn't matter what you put here.\r<br />The last argument is the FILE pointer. \r<br />\r<br />Example:\r<br /><code class=\"code prettyprint\">char *buf = (char *) malloc (20 * sizeof(char));\r<br />bytes_read = fread(buf,20, 1, fp);\r<br /></code>\r<br />\r<br />Upon a successful read, fread() returns the # of bytes read.\r<br />\r<br /><strong>fscanf()</strong>\r<br />Works just like scanf, except the first argument is a file pointer:\r<br />\r<br /><code class=\"code prettyprint\">FILE *fp;\r<br />fp = fopen(\"test.txt\",\"r\");\r<br />fscanf(fp,\"%s\",somestring);\r<br /></code>\r<br />\r<br /><strong>fgets()</strong>\r<br />\r<br />fgets() takes three parameters:\r<br />[char * variable][max # of characters to read][file pointer]\r<br />\r<br /><code class=\"code prettyprint\">fgets(somestring,50,fp);\r<br /></code>", "code":"" }    ]
}

{
    "toc":[

{"title":"Managing Loops", "section":"c"},{"title":"Using make To Compile Programs", "section":"c"},{"title":"The fork() Function", "section":"c"},{"title":"Named Pipes (FIFOs)", "section":"c"},{"title":"Using a Socket Part 3: Accepting Connections", "section":"c"},{"title":"Break and Continue In Loops", "section":"js"},{"title":"Break and Continue", "section":"shell"},{"title":"Write a Perl One-Liner", "section":"unix"},{"title":"Jobs", "section":"unix"}    ],

    "results":[


{"title" : "Managing Loops", "section":"c", "description":"<strong>continue;</strong>\r<br />Skips the rest of this iteration, starts the next one.\r<br />\r<br /><strong>break;</strong>\r<br />Ends the loop.\r<br />", "code":"" },
{"title" : "Using make To Compile Programs", "section":"c", "description":"Make is used to compile software. Make is used so you don't have to keep track of what's changed, what's not changed, what to compile etc.\r<br />\r<br /><strong>Targets And Dependencies</strong>\r<br />Make builds the target based on the dependencies of that target. Example:\r<br /><code class=\"code prettyprint\">target1.myapp: dep1.c dep2.c dep3.c\r<br /></code>\r<br />\r<br />And at the top, we specify an 'all' target with our main app as the dependency:\r<br /><code class=\"code prettyprint\">all: target1.myapp\r<br /></code>\r<br />\r<br /><strong>Rules</strong>\r<br />You can tell make how to make files. By default, if you have this:\r<br /><code class=\"code prettyprint\">myapp: test1.c test2.c\r<br /></code>\r<br />\r<br />Make will run something like:\r<br /><code class=\"code prettyprint\">gcc -o myapp test1.c test2.c\r<br /></code>\r<br />\r<br />If you want to use the -g flag, you need to write a rule. Here's the rule we'd want:\r<br /><code class=\"code prettyprint\">myapp: test1.c test2.c\r<br />&nbsp;&nbsp;gcc -g -o myapp test1.c test2.c\r<br /></code>\r<br />\r<br /><strong>NOTE: Every rule must start with a tab!</strong> This is <strong>critical</strong>. Without that tab, make will fail. You can <strong>not</strong> have spaces.\r<br />\r<br /><strong>Flags</strong>\r<br /><strong>-n</strong>: don't make, but print out what would be done.\r<br /><strong>-k</strong>: keep going, don't stop on errors, which is the default.\r<br /><strong>-f</strong>: Specify which makefile to use for make. The two defaults are:\r<br />makefile\r<br />Makefile\r<br />\r<br /><strong>Macros</strong>\r<br />Macros are like variables. They give a little flexibility to your makefile. Suppose you have a sourcefile called source.c and it's used all over your makefile. Now you need to rename it to mysource.c. Instead of doing find and replace, just use a macro:\r<br /><code class=\"code prettyprint\"># define the variable\r<br />SRC=mysource.c\r<br />\r<br /># use it\r<br />myapp: ${SRC)\r<br /></code>\r<br />\r<br />In the above example, $(SRC) just gets expanded to mysource.c when this runs. Notice we write:\r<br />SRC=mysource.c\r<br />\r<br />not:\r<br />SRC=\"mysource.c\"\r<br />\r<br />No quotes.\r<br />\r<br /><strong>Other Targets</strong>\r<br />You don't just have to specify your application as a target. Another popular one is 'clean':\r<br /><code class=\"code prettyprint\">clean:\r<br />&nbsp;&nbsp;-rm *.o\r<br /></code>\r<br />So when you type\r<br /><code class=\"code prettyprint\">make clean\r<br /></code>\r<br />If deletes all the .o files in the directory. The hyphen at the beginning means \"continue even if you got an error\" which in this case means \"even if there were no .o files to delete\". Note that if you have this:\r<br /><code class=\"code prettyprint\">myapp: test1.c test2.c\r<br />clean:\r<br />&nbsp;&nbsp;-rm *.o\r<br /></code>\r<br />\r<br />and you say:\r<br /><code class=\"code prettyprint\">make clean\r<br /></code>\r<br />\r<br />It will just delete the object files, it will NOT build myapp.\r<br />\r<br /><strong>Suffixes</strong>\r<br />A suffix rule is a directive that applies rules and macros to generic suffixes.\r<br /><strong>Step 1:</strong>\r<br />Tell make about the suffix. Here we want to write a rule for .cpp files, so:\r<br /><code class=\"code prettyprint\">SUFFIXES: .cpp\r<br /></code>\r<br />\r<br />Then you tell make that you want to convert .cpp files to .o files:\r<br /><code class=\"code prettyprint\">.cpp.o\r<br /></code>\r<br />\r<br />Then, tell it the rule:\r<br /><code class=\"code prettyprint\">$(CC) -xc++ $(CFLAGS) -I$(INCLUDE) -c $<\r<br /></code>\r<br />\r<br />Here, $< is a built in suffix macro.\r<br />\r<br /><strong>Built In Suffix Macros</strong>\r<br /><strong>$@</strong>: The full name of the current target \r<br /><strong>$?</strong>: A list of modified dependencies (a list of files newer than the target on which the target depends)\r<br /><strong>$<</strong>: The single file that is newer than the target on which the target is dependent \r<br /><strong>$*</strong>: The name of the target file, WITHOUT its suffix (i.e., without the .c or .cpp, etc.)\r<br />\r<br /><strong>Why would you use $< instead of $?</strong> ?\r<br />If you only want to use the newest dependency. Otherwise, use $?.", "code":"" },
{"title" : "The fork() Function", "section":"c", "description":"You can create a new process by calling fork(). This system call duplicates the current process, creating a new entry in the process table with many of the same attributes as the current process. Combined with the exec() functions, fork is all you need to run new programs (aka create new processes) from your program. Here's what a fork looks like:\r<br />\r<br /><code class=\"code prettyprint\">// whatever code here\r<br />\r<br />pid_t pid;\r<br />if((pid=fork())==-1)\r<br />{\r<br />//fork failed.\r<br />}else if (pid==0)\r<br />{\r<br />//this is the child\r<br />}else{\r<br />//this is the parent\r<br />}\r<br /></code>\r<br />\r<br />So as we can see, pid returns 3 values.\r<br /><strong>If it returns -1</strong>, fork failed.\r<br /><strong>If it returns 0</strong>, that means this is the child.\r<br /><strong>If it returns a positive number</strong>, that's the process ID of the child.\r<br />\r<br />So what this means is: as soon as your program hits fork, it duplicates itself. The original obviously continues running as usual. The duplicate process <strong>runs from the point after the fork call</strong>. i.e. in the above example, the duplicated process won't run any of the code marked with '//whatever code here'. It will start by evaluating pid==-1.\r<br />\r<br />The one big difference between the duplicated process (aka child process) and the original process (aka parent process) is the value that fork() returns. In the child, fork() returns 0. In the parent, fork() returns the pid, or process id, of the newly created child. That's how we check to see if we're in the child or the parent so we can run the appropriate code (usually an exec() in the child).\r<br />\r<br /><strong>Waiting for a process</strong>\r<br />Now you have two duplicate processes. They will both be running side by side; so first a little bit of code from one of the processes will run, then a little bit of code from the other process will run, back to the first, and so on. Most likely, you don't want this sort of jumble. You want the child to finish running, do whatever it has to do, and then go back to the parent and resume. This is called \"waiting for the child to finish\". There are two ways to do this:\r<br />\r<br /><strong>wait()</strong>\r<br /><code class=\"code prettyprint\">int stat_val;\r<br />pid_t child_pid;\r<br />child_pid = wait(&stat_val);\r<br /></code>\r<br />\r<br />This waits until any child finishes running. child_pid contains the pid of the child that finished running. stat_val contains the exit status.\r<br />\r<br /><strong>waitpid()</strong>\r<br />\r<br /><code class=\"code prettyprint\">int status;\r<br />waitpid(child,&status,0);\r<br /></code>\r<br />\r<br />waitpid() waits for a particular child process to exit.\r<br />\r<br />There are three choices for the first argument:\r<br /><strong>-1</strong>\r<br />waits for any child to terminate, same as wait().\r<br />\r<br /><strong>0</strong>\r<br />waits for any child process in the same process group as the current process to terminate.\r<br />\r<br /><strong>>0</strong>\r<br />Waits for the child process with the given pid to exit. You give the pid of the child process as the first argument (\"child\" in this case). Remember that you get the pid of the child process when you call fork()...so it's a pretty easy matter to just give that pid to the waitpid() function.", "code":"" },
{"title" : "Named Pipes (FIFOs)", "section":"c", "description":"So you want to transfer data between unrelated processes? Alright, use a named pipe (aka FIFO)! To do this, there are two steps: create the FIFO, and use the FIFO.\r<br />\r<br /><strong>Creating a FIFO</strong>\r<br />Use mkfifo:\r<br />\r<br /><code class=\"code prettyprint\">int res = mkfifo(\"test_fifo\",0777);\r<br /></code>\r<br />\r<br />mkfifo returns\r<br />0 on <strong>success</strong>, and\r<br />-1 on <strong>error</strong>.\r<br />\r<br /><strong>Using the FIFO</strong>\r<br />Now that you have a FIFO, you'll have one program open it for reading and the other open it for writing.\r<br />Note: you <strong>cannot have a single program open it for both reading and writing</strong>.\r<br />\r<br />Besides that, you now use the FIFO just like any other file, using open(), read() and write() to access it.\r<br />\r<br />So now we can make two simple programs, reader.c and writer.c. writer will write to the FIFO and reader will read it.\r<br />\r<br />reader.c:\r<br />\r<br /><span class=\"code\">\r<br />#include &lt;stdio.h&gt;\r<br />#include &lt;stdlib.h&gt;\r<br />#include &lt;string.h&gt;\r<br />#include &lt;unistd.h&gt;\r<br />#include &lt;fcntl.h&gt;\r<br />\r<br />int main(int argc, char * argv[])\r<br />{\r<br />&nbsp;&nbsp;// make FIFO\r<br />&nbsp;&nbsp;int res = mkfifo(\"test_fifo\",0777);\r<br />&nbsp;&nbsp;if (res==-1) printf(\"couldn't make fifo..it probably already exists\n\");\r<br />&nbsp;&nbsp;\r<br />&nbsp;&nbsp;// read from FIFO\r<br />&nbsp;&nbsp;res = open(\"test_fifo\", O_RDONLY);\r<br />&nbsp;&nbsp;char buf[128];\r<br /><strong>&nbsp;&nbsp;read(res,buf,128);</strong>\r<br />&nbsp;&nbsp;printf(\"I got this: %s\n\",buf);\r<br />&nbsp;&nbsp;return 0;\r<br />}\r<br /></span>\r<br />\r<br />writer.c:\r<br />\r<br /><code class=\"code prettyprint\">#include &lt;stdio.h&gt;\r<br />#include &lt;stdlib.h&gt;\r<br />#include &lt;string.h&gt;\r<br />#include &lt;unistd.h&gt;\r<br />#include &lt;fcntl.h&gt;\r<br />\r<br />int main(int argc, char * argv[])\r<br />{\r<br />&nbsp;&nbsp;int res = open(\"test_fifo\", O_WRONLY);\r<br />&nbsp;&nbsp;char * buf = \"this is a test.\";\r<br />&nbsp;&nbsp;write(res,buf,strlen(buf));\r<br />&nbsp;&nbsp;return 0;\r<br />}\r<br /></code>\r<br />\r<br />And if you start these programs from two different terminals, you'll see the magic of data being passed between unrelated processes. Note that reader <strong>blocks</strong> on read. i.e. it will pause on the line in bold above and wait for something to be written to the FIFO before it continues executing the rest of the program. If you don't want it to block, you need to specify O_NONBLOCK as one of the flags when you open the FIFO:\r<br />\r<br /><code class=\"code prettyprint\">&nbsp;&nbsp;res = open(\"test_fifo\", O_RDONLY | O_NONBLOCK);\r<br /></code>", "code":"" },
{"title" : "Using a Socket Part 3: Accepting Connections", "section":"c", "description":"Just like bind() and listen(), this part is done in the server program only. We accept a connection to a socket using the <strong>accept</strong> system call:\r<br />\r<br /><code class=\"code prettyprint\">#include &lt;sys/socket.h&gt;\r<br />int accept([SOCKET FD] , [STRUCT FOR CLIENT] , [SIZE OF STRUCT]);\r<br /></code>\r<br />\r<br />If you remember the structs in bind(), we'll be using the exact same structs here, except those structs were for the server and these are for whatever client connects. Here's how it works:\r<br />\r<br />1. Some client connects to the socket that the server has created. This client is just the first guy in the socket queue we created.\r<br />\r<br />2. The accept function creates a <strong>new socket</strong> to communicate with the client. So what accept() returns is the file descriptor of this new socket.\r<br />\r<br />3. Great! Now you have a file descriptor to a socket between the server and a client. You can read / write from it using the usual read / write functions.\r<br />\r<br /><strong>Parameters</strong>\r<br />\r<br />1. The file descriptor of the socket that we got through our call to socket().\r<br />\r<br />2. A struct, depending on what the domain of the socket is (AF_UNIX or AF_INET). See the section on bind() for full details.\r<br />\r<br />3. An address of a variable containing the size of the struct. Just get this using sizeof().\r<br />\r<br />Example:\r<br />\r<br /><code class=\"code prettyprint\">#include &lt;sys/types.h&gt;\r<br />#include &lt;sys/socket.h&gt;\r<br />#include &lt;sys/un.h&gt;\r<br />\r<br />// this is the struct we'll be using\r<br />struct sockaddr_un client_address;\r<br />\r<br />// accept a connection:\r<br />client_len = sizeof(client_address); // notice how we put this in a separate var...b/c we need the ADDRESS of this var as the third parameter.\r<br />int client_sockfd = accept(server_sockfd, (struct sockaddr *)&client_address, &client_len);\r<br />\r<br />// read and write to client on client_sockfd\r<br />read(client_sockfd,&ch,1); // read a character from the socket (so from the client)\r<br />ch++; // increment the character\r<br />write(client_sockfd,&ch,1); // write it back to the socket (so back to client)\r<br />close(client_sockfd); // close the socket.\r<br /></code>\r<br />\r<br />If there are no connections pending on the socket's queue, accept() will block (so the program won't continue) until a client does make a connection.", "code":"" },
{"title" : "Break and Continue In Loops", "section":"js", "description":"To exit a loop, use:\r<br /><code class=\"code prettyprint\">break;\r<br /></code>\r<br />\r<br />To go to the next iteration in a loop, use:\r<br /><code class=\"code prettyprint\">continue;\r<br /></code>\r<br />\r<br />If you have more than one loop and you want to specify which one to break or continue, ass a label to the loop like this:\r<br /><code class=\"code prettyprint\">myLabel: // this is the label of the loop\r<br />while(1==0) // some loop\r<br />{\r<br />&nbsp;&nbsp;break myLabel; // specify label in break\r<br />}\r<br /></code>", "code":"" },
{"title" : "Break and Continue", "section":"shell", "description":"You can break out of loops by using break;\r<br />You can skip the current iteration of a loop by using continue;", "code":"" },
{"title" : "Write a Perl One-Liner", "section":"unix", "description":"-p flag puts a \r<br /><span class=\"code\">\r<br />while (<>) {\r<br />  # your code goes here\r<br />} continue {\r<br />  print or die \"-p destination: $!\n\";\r<br />}\r<br /></span>\r<br />around the entire one-liner.\r<br />\r<br />-i flag makes any edits to the original files.\r<br />\r<br />-e says that the one liner is following this flag.", "code":"perl -p -i -e 'insert one liner here' optionalargs.txt\r<br />\r<br />#one-liner to find and replace across a bunch of files in a folder:\r<br />perl -pi -e 's/findthisstring/replacewiththis/g' *" },
{"title" : "Jobs", "section":"unix", "description":"<strong>See Current Jobs:</strong>\r<br /><code class=\"code prettyprint\">jobs\r<br /></code>\r<br />\r<br /><strong>Manage Jobs:</strong>\r<br />Ctrl-Z = pause job (you'll get taken straight back to the command line)\r<br />fg = return to job\r<br />fg %1 = return to job number 1\r<br />kill %1 = stop job # 1\r<br />\r<br /><strong>Put Jobs In The Background:</strong>\r<br />put a & at the end of the command to have it run in the background. It will still continue to output to the screen though, so if you don't want that, redirect STDOUT and STDERR like this:\r<br /><code class=\"code prettyprint\">[somejob] >stoutanderr.txt 2>&1 &\r<br /></code>\r<br />\r<br />A job is not the same thing as a process. A job is a program running inside a process.\r<br />If you have a job running and you exit the shell, that job is killed.\r<br />", "code":"" }    ]
}

\hypertarget{_matrix_functions_8cpp}{
\section{MatrixFunctions.cpp File Reference}
\label{_matrix_functions_8cpp}\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}}
}
{\ttfamily \#include $<$memory$>$}\par
{\ttfamily \#include \char`\"{}MatrixFunctions.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}Matrix.h\char`\"{}}\par
{\ttfamily \#include $<$boost/tuple/tuple.hpp$>$}\par
{\ttfamily \#include $<$boost/shared\_\-ptr.hpp$>$}\par
{\ttfamily \#include $<$algorithm$>$}\par
{\ttfamily \#include $<$limits$>$}\par
Include dependency graph for MatrixFunctions.cpp:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=335pt]{_matrix_functions_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{_matrix_functions_8cpp_aa7678f1d5dfe64cad1897e1a78da2c10}{findNonZero} (\hyperlink{class_matrix}{Matrix} \&m, int col)
\begin{DoxyCompactList}\small\item\em Given a \hyperlink{class_matrix}{Matrix} and a column number, this functions returns the index of the first row which has a non-\/zero value in that column. \item\end{DoxyCompactList}\item 
\hyperlink{class_matrix}{Matrix} \hyperlink{_matrix_functions_8cpp_aec58045132edaf43914a134b4eb2697f}{gaussJordan} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. \item\end{DoxyCompactList}\item 
\hyperlink{class_matrix}{Matrix} \hyperlink{_matrix_functions_8cpp_a5ab64c0532a96fd250bf278423b326cf}{gaussianElimination} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. \item\end{DoxyCompactList}\item 
boost::tuple$<$ \hyperlink{class_matrix}{Matrix}, \hyperlink{class_matrix}{Matrix}, \hyperlink{class_matrix}{Matrix} $>$ \hyperlink{_matrix_functions_8cpp_a4211ea2b9a4462e11be36b7ab09ebf5a}{LUPDecompose} (\hyperlink{class_matrix}{Matrix} A)
\begin{DoxyCompactList}\small\item\em Given a matrix, returns it's LUP decomposition. \item\end{DoxyCompactList}\item 
bool \hyperlink{_matrix_functions_8cpp_afd17d61898fe54cfb57b97238a20eab5}{isSymmetric} (\hyperlink{class_matrix}{Matrix} \&A)
\begin{DoxyCompactList}\small\item\em Checks whether a matrix is symmetric or not. \item\end{DoxyCompactList}\item 
\hyperlink{class_matrix}{Matrix} \hyperlink{_matrix_functions_8cpp_a0ad9f45bf1edd75781d68413d162cb0c}{steepestDescent} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. \item\end{DoxyCompactList}\item 
\hyperlink{class_matrix}{Matrix} \hyperlink{_matrix_functions_8cpp_a12c19521809b4f556360bbea91aea576}{conjugateGradient} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. \item\end{DoxyCompactList}\item 
\hyperlink{class_matrix}{Matrix} \hyperlink{_matrix_functions_8cpp_aaf686c3d17b6c76f2d79e291a31c2d02}{jacobi} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. \item\end{DoxyCompactList}\item 
int \hyperlink{_matrix_functions_8cpp_af2959f191427ede389ab67e042741261}{simplex} (\hyperlink{class_matrix}{Matrix} \&A, \hyperlink{class_matrix}{Matrix} \&b)
\begin{DoxyCompactList}\small\item\em Solve a Linear Programming Problem using the Simplex Method. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{_matrix_functions_8cpp_a12c19521809b4f556360bbea91aea576}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!conjugateGradient@{conjugateGradient}}
\index{conjugateGradient@{conjugateGradient}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{conjugateGradient}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} conjugateGradient ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_a12c19521809b4f556360bbea91aea576}


Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. 

Uses the Method of Conjugate Gradients. This is an iterative method. On sparse matrices, this will usually be faster than using gaussianElimination, gaussJordan and steepestDescent as well (it's a modified version of steepestDescent).

Warning: A needs to be symmetric and positive definite.

Returns a \hyperlink{class_matrix}{Matrix} object containing the solution. \hypertarget{_matrix_functions_8cpp_aa7678f1d5dfe64cad1897e1a78da2c10}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!findNonZero@{findNonZero}}
\index{findNonZero@{findNonZero}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{findNonZero}]{\setlength{\rightskip}{0pt plus 5cm}int findNonZero ({\bf Matrix} \& {\em m}, \/  int {\em col})}}
\label{_matrix_functions_8cpp_aa7678f1d5dfe64cad1897e1a78da2c10}


Given a \hyperlink{class_matrix}{Matrix} and a column number, this functions returns the index of the first row which has a non-\/zero value in that column. 

If all rows have zeroes, it returns -\/1. This function is used by both gaussJordan and gaussianElimination. \hypertarget{_matrix_functions_8cpp_a5ab64c0532a96fd250bf278423b326cf}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!gaussianElimination@{gaussianElimination}}
\index{gaussianElimination@{gaussianElimination}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{gaussianElimination}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} \& gaussianElimination ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_a5ab64c0532a96fd250bf278423b326cf}


Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. 

Uses Gaussian Elimination with backsubstitution. This is faster than using gaussJordan. Returns a \hyperlink{class_matrix}{Matrix} object containing the solution. \hypertarget{_matrix_functions_8cpp_aec58045132edaf43914a134b4eb2697f}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!gaussJordan@{gaussJordan}}
\index{gaussJordan@{gaussJordan}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{gaussJordan}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} \& gaussJordan ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_aec58045132edaf43914a134b4eb2697f}


Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. 

Uses Gauss-\/Jordan. Returns a \hyperlink{class_matrix}{Matrix} object containing the solution. \hypertarget{_matrix_functions_8cpp_afd17d61898fe54cfb57b97238a20eab5}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!isSymmetric@{isSymmetric}}
\index{isSymmetric@{isSymmetric}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{isSymmetric}]{\setlength{\rightskip}{0pt plus 5cm}bool isSymmetric ({\bf Matrix} \& {\em A})}}
\label{_matrix_functions_8cpp_afd17d61898fe54cfb57b97238a20eab5}


Checks whether a matrix is symmetric or not. 

\hypertarget{_matrix_functions_8cpp_aaf686c3d17b6c76f2d79e291a31c2d02}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!jacobi@{jacobi}}
\index{jacobi@{jacobi}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{jacobi}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} jacobi ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_aaf686c3d17b6c76f2d79e291a31c2d02}


Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. 

Uses the Jacobi Method. This is an iterative method.

Warning: A needs to be strictly or irreducibly diagonally dominant. Strict row diagonal dominance means that for each row, the absolute value of the diagonal term is greater than the sum of the absolute values of the other terms.

Returns a \hyperlink{class_matrix}{Matrix} object containing the solution. \hypertarget{_matrix_functions_8cpp_a4211ea2b9a4462e11be36b7ab09ebf5a}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!LUPDecompose@{LUPDecompose}}
\index{LUPDecompose@{LUPDecompose}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{LUPDecompose}]{\setlength{\rightskip}{0pt plus 5cm}boost::tuple$<$ {\bf Matrix}, {\bf Matrix}, {\bf Matrix} $>$ LUPDecompose ({\bf Matrix} {\em A})}}
\label{_matrix_functions_8cpp_a4211ea2b9a4462e11be36b7ab09ebf5a}


Given a matrix, returns it's LUP decomposition. 

Three matrices L, U and P are returned as a boost tuple. Example usage: 
\begin{DoxyCode}
    #include "boost/tuple/tuple.hpp"

    // create a new matrix
    Matrix A(3,3);
    A.populateRandom();
  
    // get its decomposition
    boost::tuple<Matrix,Matrix,Matrix> lu = LUPDecompose(A);
    Matrix L = lu.get<0>();
    Matrix U = lu.get<1>();
    Matrix P = lu.get<2>();
    
    // print out matrices
    cout << L << endl;
    cout << U << endl;
    cout << P << endl;
\end{DoxyCode}
 \hypertarget{_matrix_functions_8cpp_af2959f191427ede389ab67e042741261}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!simplex@{simplex}}
\index{simplex@{simplex}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{simplex}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} simplex ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_af2959f191427ede389ab67e042741261}


Solve a Linear Programming Problem using the Simplex Method. 

\hypertarget{_matrix_functions_8cpp_a0ad9f45bf1edd75781d68413d162cb0c}{
\index{MatrixFunctions.cpp@{MatrixFunctions.cpp}!steepestDescent@{steepestDescent}}
\index{steepestDescent@{steepestDescent}!MatrixFunctions.cpp@{MatrixFunctions.cpp}}
\subsubsection[{steepestDescent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} steepestDescent ({\bf Matrix} \& {\em A}, \/  {\bf Matrix} \& {\em b})}}
\label{_matrix_functions_8cpp_a0ad9f45bf1edd75781d68413d162cb0c}


Given two matrices A and b, solves the linear system of equations assuming the form Ax = b. 

Uses the Method of Steepest Descent. This is an iterative method. On sparse matrices, this will usually be faster than using gaussianElimination or gaussJordan.

Warning: A needs to be symmetric and positive definite.

Returns a \hyperlink{class_matrix}{Matrix} object containing the solution. 